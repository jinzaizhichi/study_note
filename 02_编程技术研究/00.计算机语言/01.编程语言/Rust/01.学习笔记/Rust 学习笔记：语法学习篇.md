# Rust 学习笔记：语法学习篇

根据之前在《[[Rust 语言的学习路线图]]》一文中的规划，这篇学习笔记将用于记录本人在学习 Rust 编程语言的   语法时所撰写的学习心得与代码实例。该笔记的内容将会被分别保存在[本人的笔记库项目](https://github.com/owlman/study_note)的`Programming/LanguageStudy/Rust/`目录下的以下两个子目录中：

- `StudyNotes`目录：用于存放 Markdown 格式的笔记。
- `examples`目录：则用于存放笔记中所编写的代码实例。

## 数据类型

基本上，一门编程语言所支持的数据类型会决定使用该语言编写的代码可对数据执行的操作，例如：如果编程语言支持整数类型，我们就可以用它来编写用于执行加、减、乘等整数运算的代码，如果它除此之外还支持浮点类型，那么我们就可以进而在代码中执行更为复杂的数值计算了。如果它对字符类型也提供了支持，那我们就还可以用该语言编写用于文本处理的代码了。总而言之，编程语言支持的数据类型直接决定了该语言的表达能力，而编程语言的表达能力又决定了它能解决的问题。所以，和大多数编程语言的学习一样，我们对 Rust 语言的了解也需要从它支持的数据类型开始。

关于数据类型的学习，读者首先要明确的是，Rust 在分类上属于强类型的编译型语言。具体来说，编译型语言指的是 Rust 采用的是静态类型系统，该系统要求编程语言使用的数据类型必须在代码的编译期被确定下来。而强类型则意味着我们在该语言中使用的每个数据都必须要有确切的类型。下面我们将会先从基元类型开始介绍 Rust 语言支持的数据类型。

### 基元类型

在编程语言中，基元类型指的是该语言所能支持的、原子性的基本数据类型，程序员之后在日常编程中所要执行的各种运算符操作、集合类操作、流程控制操作、函数与对象的定义操作都必须基于基元类型来展开，所以我们在深入学习 Rust 语言的语法之前，必须要先了解该语言的基元类型，这些数据类型具体如下。

- 整数类型：Rust 语言支持的整数类型大致可分为有符号整数与无符号整数两大类，其中：
  - 有符号整数类型包括`i8`、`i16`、`i32`、`i64`、`i128`；
  - 无符号整数类型包括`u8`、`u16`、`u32`、`u64`、`u128`；
  - `isize`类型：大小可变的有符号整数类型（具体取决于底层指针的大小），相当于 32 位 CPU 中`i32`类型或 64 位 CPU 中`i64`类型。
  - `usize`类型：大小可变的无符号整数类型（具体取决于底层指针的大小），相当于 32 位 CPU 中`u32`类型或 64 位 CPU 中`u64`类型。
- 浮点数类型：Rust 语言主要支持有`f32`和`f64`两种浮点数类型，都可用于表示参与数值运算的浮点数。
- 布尔类型：取值非`true`即`false`，通常用于二元判断。
- 字符类型：取值通常是 10 个阿拉伯数字和 26 个英文字母（包括其大小写形态）。

### 集合类型

在了解了语言支持的基元类型之后，程序员们就可以利用基元类型组合出更为复杂的数据类型了，其中最简单的组合方式当属集合了。在编程语言中，程序员通常将用某种逻辑把多个基元类型的数据组合起来表示某一种集合概念的数据类型称之为集合类型，具体到 Rust 语言中，我们使用的集合类型主要有元组和数组两种形式，下面来逐一介绍一下它们。

- 元组类型：这是将隶属于多种类型的多个数据组合到一个集合中的基本方式。元组的长度是固定的，这意味着该集合类型的数据在被声明后，集合中的元素值及其数量都是不能改变的。程序员可以通过在小括号内写入以逗号分隔的值列表来创建一个元组，语法形式为：`(元素类型、元素类型....元素类型)`。在这里，每个`元素类型`都可以是一个基元类型、集合类型、自定义类型（我们稍后会具体介绍自定义类型），并且元组中不同值的类型不要求是相同的。下面我们来看一个具体的例子：

    ```rust
    fn main() {
        let tup: (i32, f64, u8) = (500, 6.4, 1);
    }
    ```

变量 tup 绑定到整个元组，因为元组被认作是单个复合元素。 想从元组中获取个别值，我们可以使用模式匹配来解构（destructure）元组的一个值，如下所示：

文件名：src/main.rs


fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
该程序首先创建一个元组并将其绑定到变量 tup 上。 然后它借助 let 来使用一个模式匹配 tup，并将它分解成三个单独的变量 x、y 和 z。 这过程称为解构（destructuring），因为它将单个元组分为三部分。最后，程序打印出 y 值，为 6.4。

除了通过模式匹配进行解构外，我们还可以使用一个句点（.）连上要访问的值的索引来直接访问元组元素。例如：

文件名：src/main.rs


fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
该程序创建一个元组 x，然后通过使用它们的索引为每个元素创建新的变量。和大多数编程语言一样，元组中的第一个索引为 0。

没有任何值的元组 () 是一种特殊的类型，只有一个值，也写成 ()。该类型被称为单元类型（unit type），该值被称为单元值（unit value）。如果表达式不返回任何其他值，就隐式地返回单元值。

数组类型
将多个值组合在一起的另一种方式就是使用数组（array）。与元组不同，数组的每个元素必须具有相同的类型。与某些其他语言中的数组不同，Rust 中的数组具有固定长度。

我们在方括号内以逗号分隔的列表形式将值写到数组中：

文件名：src/main.rs


fn main() {
    let a = [1, 2, 3, 4, 5];
}
当你希望将数据分配到栈（stack）而不是堆（heap）时（我们将在第 4 章)中进一步讨论栈和堆），或者当你希望确保始终具有固定数量的元素时，数组特别有用。但它们不像 vector （译注：中文字面翻译为“向量”，在 Rust 中意义为“动态数组，可变数组”）类型那么灵活。vector 类型类似于标准库中提供的集合类型，其大小允许增长或缩小。如果不确定是使用数组还是 vector，那就应该使用一个 vector。第 8 章将详细地讨论 vector。

不过当你明确元素数量不需要改变时，数组会更有用。例如，如果你在程序中使用月份的名称，你很可能希望使用的是数组而不是 vector，因为你知道它始终包含 12 个元素：



let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
使用方括号编写数组的类型，其中包含每个元素的类型、分号，然后是数组中的元素数，如下所示：



let a: [i32; 5] = [1, 2, 3, 4, 5];
这里，i32 是每个元素的类型。分号之后，数字 5 表明该数组包含 5 个元素。

以这种方式编写数组的类型看起来类似于初始化数组的另一种语法：如果要为每个元素创建包含相同值的数组，可以指定初始值，后跟分号，然后在方括号中指定数组的长度，如下所示：

对于每个元素都相同的情况，还可以通过指定初始值、后跟分号和方括号中的数组长度来初始化数组，如下所示：



let a = [3; 5];
变量名为 a 的数组将包含 5 个元素，这些元素的值初始化为 3。这种写法与 let a = [3, 3, 3, 3, 3]; 效果相同，但更简洁。

访问数组元素
数组是可以在栈上分配的已知固定大小的单个内存块。可以使用索引访问数组的元素，如下所示：

文件名：src/main.rs


fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
在这个例子中，名为 first 的变量将获得值 1，因为它是数组中索引 [0] 处的值。名为 second 的变量将从数组中的索引 [1] 中获取得 2。

无效的数组元素访问
如果尝试访问超出数组末尾的数组元素，会发生什么？ 假如你将示例更改为以下内容，使用类似于第 2 章猜数字游戏的代码那样从用户获取数组索引：

文件名：src/main.rs

This code panics!
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!(
        "The value of the element at index {} is: {}",
        index, element
    );
}
此代码编译成功。如果使用 cargo run 来运行此代码并输入 0、1、2、3 或 4，则程序将打印数组对应索引的值。如果输入的是超出数组末尾的数字，例如 10，则会看到类似以下的输出：


thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
该程序在索引操作中使用无效值时导致运行时（runtime）错误。程序退出并显示错误消息，未执行后面的 println! 语句。当你尝试使用索引访问元素时，Rust 将检查你指定的索引是否小于数组长度。如果索引大于或等于数组长度，Rust 会出现 panic。这种检查必须在运行时进行，尤其是在这种情况下，因为编译器可能无法知道用户之后运行代码时将输入什么值。

这是 Rust 在实践中安全原则的第一个例子。在很多低级语言中，并不进行这种检查，而且在你使用不正确的索引时，可以访问无效的内存。Rust 通过立即退出来的方式防止这种错误，而不是允许内存访问并继续运行程序。第 9 章将进一步讨论 Rust 的错误处理。

### 自定义类型

自定义数据类型主要有结构体。枚举和联合三种形式，下面来逐一介绍一下它们。

首先是结构体类型，在 Rust 语言中，结构体的功能要比 C 语言

## 变量与集合

- `[T; N]`类型：固定大小的数组类型，在这里，`T`表示的是数组元素的数据类型，而`N`则用于表示数组元素的数量，它必须是一个大于或等于 0 的整数。
- `[T]`类型：动态大小的数据类型，在这里，`T`表示的是数组元素的数据类型。
- `[T,U,...]`类型：有限序列类型，该序列中的每个元素不必是同一数据类型，例如在这里，`T`和`U`可以是不同类型的数据。

## 流程控制

## 函数、闭包与宏

在 Rust 语言中，函数本质上也是一种数据类型，该类型的表示方式通常是`fn([参数列表) -> [返回值类型]`。

--------------------------------
#待深入
